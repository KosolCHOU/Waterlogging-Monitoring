{% extends "base.html" %}
{% block title %}Dashboard – CropXcel{% endblock %}

{% block head %}
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    html, body { height:100%; overflow:hidden; margin:0; background:#f1f5f9;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif; }

    /* ===== LAYOUT ===== */
    .pagebrand{ padding:6px 10px 0 10px; }
    .pagebrand span{
      font-weight:900;font-size:20px;
      background:#fff;border-radius:8px;padding:4px 8px;
      box-shadow:0 2px 8px rgba(0,0,0,.06);
    }
        .pagebrand{ padding:6px 10px 0 10px; }
    .pagebrand span{
      font-weight:900;font-size:20px;
      background:#fff;border-radius:8px;padding:4px 8px;
      box-shadow:0 2px 8px rgba(0,0,0,.06);
    }
    .dash{ display:grid; grid-template-columns: 1.35fr 1fr; gap:12px; padding:10px;
           height: calc(100vh - 20px); box-sizing:border-box; }
    .mapCard{ position:relative; background:#fff; border-radius:14px;
              box-shadow:0 8px 24px rgba(0,0,0,.12); overflow:hidden; height:100%; }
    .exit-maponly{ position:absolute; right:12px; top:12px; z-index:1000; display:none; }
    .mapCard .leaflet-container{ height:100% !important; width:100% !important; }

    .colR{ display:flex; flex-direction:column; gap:12px; height:100%; min-height:0; overflow:auto; }
    .card{ background:#fff; border-radius:14px; box-shadow:0 8px 24px rgba(0,0,0,.12);
           padding:12px; overflow:hidden; flex:0 0 auto; }
    .card-head{ display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:8px; }
    .pretty{ margin:0; font-size:16px; font-weight:800; letter-spacing:.2px; color:#0f172a; position:relative; padding-left:18px; }
    .pretty::before{ content:""; width:10px; height:10px; border-radius:50%; position:absolute; left:0; top:4px;
                     background: radial-gradient(circle at 30% 30%, #34d399, #0ea5e9); box-shadow: 0 0 0 2px #fff; }
    .head-actions{ display:flex; gap:10px; flex-wrap:wrap; }
    .btn{ background:#e2e8f0; color:#0f172a; border:0; cursor:pointer; padding:8px 14px; border-radius:999px; font-weight:600; }
    .btn.btn-brand{ background:#0ea5e9; color:#fff; }

    /* Map-only mode */
    body.map-only .colR{ display:none; }
    body.map-only .dash{ grid-template-columns:1fr; }
    body.map-only .mapCard{ height:100%; }
    body.map-only .exit-maponly{ display:block; }

    @media (max-width: 1024px){ .dash{ grid-template-columns: 1fr; } }

    /* ===== TABLES ===== */
    .minitable{ width:100%; border-collapse:separate; border-spacing:0; font-size:12px; border-radius:12px; overflow:hidden; }
    .minitable th, .minitable td{
      padding:6px 8px; border-bottom:1px solid #e5e7eb; color:#0f172a; vertical-align:middle;
      text-overflow:ellipsis; overflow:hidden; white-space:nowrap; font-weight:500;
    }
    .minitable thead th{ position:sticky; top:0; background:linear-gradient(#fff,#f8fafc); font-weight:800; z-index:1;
                         box-shadow: inset 0 -1px 0 #e5e7eb, 0 1px 0 rgba(0,0,0,.02); }
    .minitable tbody tr:nth-child(even){ background:#fafafa; }
    .minitable tbody tr:hover{ background:#eef6ff; box-shadow:inset 0 0 0 9999px rgba(14,165,233,.06); }

    .minitable.farmer{ table-layout:fixed; }
    .minitable.farmer th, .minitable.farmer td{ height:32px; text-align:center; }
    /* Farmer table: friendlier look */
    .minitable.farmer td, .minitable.farmer th {
      text-align: left;   /* left align for readability */
      font-size: 13px;
      padding: 8px 10px;
    }

    /* Status badge */
    .minitable.farmer td.status-cell {
      font-weight: 700;
    }
    .minitable.farmer td.status-cell span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
    }
    .minitable.farmer td.status-cell span.healthy { background: #22c55e; }
    .minitable.farmer td.status-cell span.watch   { background: #f59e0b; }
    .minitable.farmer td.status-cell span.alert   { background: #ef4444; }

    /* Action bubble */
    .minitable.farmer td.action-cell {
      font-size: 12px;
      line-height: 1.4;
    }
    .minitable.farmer td.action-cell div {
      background: #f1f5f9;
      border-radius: 8px;
      padding: 6px 8px;
    }

    .minitable.tech{ table-layout:auto; min-width:980px; font-variant-numeric:tabular-nums; }
    .minitable.tech th, .minitable.tech td{ height:30px; white-space:nowrap; text-align:center; }
    .minitable.tech td:first-child, .minitable.tech th:first-child{ text-align:left; position:sticky; left:0; z-index:2; background:inherit; box-shadow:1px 0 0 #e5e7eb; }
    .minitable.tech td.spark{ background: linear-gradient(90deg, rgba(14,165,233,.25) calc(var(--pct,0)*1%), transparent 0); border-radius:6px; }

    .tech-wrap{ overflow:auto; scrollbar-gutter:stable both-edges; }
    .tech-wrap::-webkit-scrollbar{ height:10px; width:10px; }
    .tech-wrap::-webkit-scrollbar-thumb{ background:#cbd5e1; border-radius:999px; }
    .tech-wrap::-webkit-scrollbar-track{ background:#f1f5f9; }

    th.sortable{ cursor:pointer; user-select:none; }
    th.sortable::after{ content:"▾"; margin-left:6px; opacity:.35; font-size:12px; }
    th.sortable.asc::after{ content:"▴"; }

    /* ===== ANALYSIS SCALE ===== */
    .scaleRow { display:grid; grid-template-columns: 160px 1fr; gap:14px; align-items:center; padding: 4px 2px; }
    .donutWrap{ display:flex; align-items:center; justify-content:center; }
    .legend { display:grid; grid-template-columns:1fr; gap:8px; }
    .legrow{
      display:grid;
      grid-template-columns:auto 1fr auto 1fr auto; /* bubble | name | ha | bar | % */
      align-items:center; gap:10px; padding:6px 8px;
      border-radius:10px; background:#f8fafc;
    }
    .legrow:hover { background:#f1f5f9; }
    .bubble{ width:12px; height:12px; border-radius:50%; background:var(--c);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.9), 0 0 0 1px rgba(0,0,0,.08); }
    .lg-name{ color:#0f172a; font-weight:600; white-space:nowrap; }
    .lg-pill{ font-size:11px; color:#0f172a; background:#e5e7eb; padding:2px 6px; border-radius:999px; white-space:nowrap; }
    .lg-bar{ height:8px; background:#e5e7eb; border-radius:999px; position:relative; overflow:hidden; }
    .lg-bar .fill{ position:absolute; inset:0 auto 0 0; width:calc(var(--pct)*1%); background:var(--c); border-radius:999px; transition:width .6s ease; }
    .lg-val{ font-variant-numeric:tabular-nums; color:#0f172a; text-align:right; min-width:48px; }

    .total-chip{ font-size:16px; color:#0f172a; background:#e5e7eb; padding:2px 8px; border-radius:999px; }

    /* Donut */
    .scaleRow svg circle { vector-effect: non-scaling-stroke; }
    .scale-donut .segments .seg{ transition: stroke-dasharray .45s ease, stroke .2s ease; stroke-linecap:round; }
    .scale-donut .seg-0{ stroke:#2ecc71; } /* Healthy */
    .scale-donut .seg-1{ stroke:#f1c40f; } /* Watch   */
    .scale-donut .seg-3{ stroke:#e74c3c; } /* Alert   */

    /* Hover pill (for simple server probe) */
    #hoverpill{position:absolute;top:10px;left:10px;z-index:1000;display:none;
      background:#0f172a;color:#fff;padding:6px 10px;border-radius:999px;font-size:12px;opacity:.92}
    #toggleInsights {
      display: block;          /* makes it respect width */
      width: 100%;             /* full width of its container */
      text-align: center;      /* center the text */
      margin-top: 8px;         /* keep your spacing */
    }
    @keyframes spinCW {
      from { transform: rotate(0deg); }
      to   { transform: rotate(360deg); }
    }
    @keyframes spinCCW {
      from { transform: rotate(360deg); }
      to   { transform: rotate(0deg); }
    }

    .scale-donut .seg-0 {
      transform-origin: 70px 70px;
      animation: spinCW 12s linear infinite;
    }
    .scale-donut .seg-1 {
      transform-origin: 70px 70px;
      animation: spinCCW 18s linear infinite;
    }
    .scale-donut .seg-2 {
      transform-origin: 70px 70px;
      animation: spinCW 24s linear infinite;
    }
    .scale-donut .seg-3 {
      transform-origin: 70px 70px;
      animation: spinCCW 30s linear infinite;
    }
    /* Donut center chip */
    #donutCenterChip circle.inner {
      fill:#ffffff; stroke:#e5e7eb; stroke-width:1.5;
      filter: drop-shadow(0 1px 1.5px rgba(0,0,0,.06));
    }
    #donutCenter { font-size:18px; font-weight:800; fill:#0f172a; }
    #donutUnit   { font-size:11px; fill:#475569; }  /* "Ha" */
    #donutLabel  { font-size:10px; fill:#64748b; }

    /* Tiny info tooltip next to "Analysis Scale" */
    .info {
      display:inline-flex; align-items:center; justify-content:center;
      width:18px; height:18px; margin-left:6px; border-radius:999px;
      background:#e2e8f0; color:#0f172a; font-size:12px; font-weight:700;
      cursor:default; position:relative;
    }
    .info:hover { background:#cbd5e1; }
    .info .tip {
      display:none; position:absolute; left:22px; top:50%; transform:translateY(-50%);
      padding:8px 10px; background:#0f172a; color:#fff; border-radius:8px;
      font-size:12px; max-width:240px; line-height:1.35;
      box-shadow:0 8px 24px rgba(0,0,0,.18);
    }
    .info:hover .tip { display:block; }
    .info .tip::before{
      content:""; position:absolute; left:-6px; top:50%; transform:translateY(-50%);
      width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent;border-right:6px solid #0f172a;
    }
    #donutCenterChip { transition: transform .25s ease; }
    .scaleRow:hover #donutCenterChip { transform: scale(1.02); }
    /* Info icon */
    .info {
      display:inline-flex; align-items:center; justify-content:center;
      width:18px; height:18px; margin-left:6px; border-radius:999px;
      background:#e2e8f0; color:#0f172a; font-size:12px; font-weight:700;
      cursor:default; position:relative;
    }
    .info:hover { background:#cbd5e1; }

    /* Tooltip bubble */
    .info .tip {
      display:none;
      position:absolute;
      top:125%; left:50%; transform:translateX(-50%);
      padding:8px 12px;
      background:#0f172a; color:#fff;
      border-radius:8px;
      font-size:12px; line-height:1.4;
      max-width:260px;
      text-align:left;
      box-shadow:0 6px 18px rgba(0,0,0,.18);
      white-space:normal;          /* ✅ allow wrapping */
      z-index:1000;
    }
    .info:hover .tip { display:block; }

    /* Tooltip arrow */
    .info .tip::before {
      content:"";
      position:absolute;
      top:-6px; left:50%; transform:translateX(-50%);
      border-width:0 6px 6px 6px;
      border-style:solid;
      border-color:transparent transparent #0f172a transparent;
    }
    /* === Reusable hover tooltip icon === */
    .hint{
      display:inline-block; width:18px; height:18px; margin-left:6px;
      border-radius:999px; background:#e2e8f0; position:relative; vertical-align:middle;
    }
    .hint::before{
      content:"i"; position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      font:700 12px/18px system-ui; color:#0f172a;
    }
    .hint:hover{ background:#cbd5e1; }

    /* Default: dock to the right of the icon */
    .hint::after {
      content: attr(data-tip);
      position: absolute;
      top: 50%;
      left: 105%;
      transform: translateY(-50%);
      background: #0f172a;
      color: #fff;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.45;
      min-width: 220px;
      max-width: 320px;
      max-height: 60vh;
      overflow-y: auto;
      white-space: normal;
      box-shadow: 0 8px 24px rgba(0,0,0,.18);
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }

    .hint:hover::after {
      opacity: 1;
      transform: translateY(-50%) translateX(6px);
    }

    /* Special tweak: Per-pass Insights bubble → push down */
    #insTitle .hint::after {
      top: 80%;               /* instead of 50%, moves bubble lower */
      transform: translateY(0) translateX(6px);
    }

    /* Ensure cards don’t clip the tooltip */
    .card {
      overflow: visible !important;
    }
  </style>
{% endblock %}

{% block content %}

<div class="dash">
  <!-- LEFT: MAP -->
  <div class="mapCard">
    <div id="map" style="height:100%; width:100%"></div>
    <div id="hoverpill"></div>
    <button class="btn btn-brand exit-maponly" id="exitMapOnlyBtn" title="Exit Map Only">Exit Map Only</button>
  </div>

  <!-- RIGHT: Insights, Scale, Plot -->
  <div class="colR">
    <div class="card">
      <div class="card-head">
        <h3 id="insTitle" class="pretty">
          Per-pass Insights
          <span class="hint" data-tip="Each row comes from a Sentinel-1 satellite pass. It shows the date, your field’s risk level, and what you should do. Farmers can use this to decide when to irrigate, drain, or simply monitor."></span>
        </h3>
        <div class="head-actions">
          <button class="btn btn-brand" id="techBtn">Show Technical Details</button>
          <button class="btn btn-brand" id="mapOnlyBtn">Map Only</button>
        </div>
      </div>

      <div class="tech-wrap">
        <div id="insightsTable" data-max="5" data-tech-max="5">
          <!-- filled by fetch -->
        </div>
      </div>

      <button class="btn" id="toggleInsights" style="margin-top:8px;">Show more</button>
    </div>

    <div class="card">
      <div class="card-head">
        <div class="pretty">
          Analysis Scale
          <span class="hint" data-tip="Breaks your field into Healthy, Watch, and Alert zones. The areas are estimated from pixels, helping you see which part of the field may need urgent action."></span>
        </div>
      </div>
      <div class="scaleRow">
        <!-- Donut -->
        <div class="donutWrap">
          <!-- Analysis Scale donut -->
          <svg class="scale-donut" width="140" height="140" viewBox="0 0 140 140" aria-label="Analysis Scale">
            <!-- STATIC background rings (drawn first) -->
            <g class="bg" transform="rotate(-90 70 70)">
              <circle cx="70" cy="70" r="58" fill="none" stroke="#e5e7eb" stroke-width="10"/>
              <circle cx="70" cy="70" r="46" fill="none" stroke="#e5e7eb" stroke-width="10"/>
              <circle cx="70" cy="70" r="34" fill="none" stroke="#e5e7eb" stroke-width="10"/>
            </g>

            <!-- ROTATING, COLORED segments (drawn on top) -->
            <g class="segments" transform="rotate(-90 70 70)" data-sw="10">
              <circle class="seg seg-0" cx="70" cy="70" r="58" fill="none" stroke-width="10" pathLength="100"/>
              <circle class="seg seg-1" cx="70" cy="70" r="46" fill="none" stroke-width="10" pathLength="100"/>
              <circle class="seg seg-2" cx="70" cy="70" r="34" fill="none" stroke-width="10" pathLength="100"/>
            </g>

            <!-- Center chip -->
            <g id="donutCenterChip">
              <circle class="inner" cx="70" cy="70" r="26"></circle>
              <text id="donutCenter" x="70" y="68" text-anchor="middle">0.00</text>
              <text id="donutUnit"   x="70" y="83" text-anchor="middle">Ha</text>
            </g>
          </svg>
        </div>
        <!-- Legend -->
        <div class="legend">
          <div id="legendRows"><!-- injected rows --></div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3 class="pretty">
        Plot
        <span class="hint" data-tip="A 4-month history of waterlogging risk. Farmers can spot trends: if risk is climbing, prepare drainage; if it’s falling, you’re safe to irrigate. Helps you plan day-to-day decisions."></span>
      </h3>
      <div id="plotSection"><!-- injected --></div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  // --- context from Django ---
  const JOB_ID     = {{ job_id|safe }};
  const BOUNDS     = {{ bounds|safe }};               // [[S,W],[N,E]]
  const OVERLAY_URL= "{{ overlay_png|default:'' }}";
  const HOTSPOTS   = "{{ hotspots_url|default:'' }}";
  const PROBE_BIN  = "{{ probe_bin|default:'' }}";
  const PROBE_META = "{{ probe_meta|default:'' }}";
  const FIELD_ID   = {{ field.id }};

  /* ================= MAP ================= */
  const map = L.map('map');
  L.tileLayer(
    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
    { attribution: 'Tiles © Esri' }
  ).addTo(map);
  map.fitBounds(BOUNDS);

  map.createPane('overlayPane');
  map.getPane('overlayPane').style.zIndex = 450;

  if (OVERLAY_URL && OVERLAY_URL.endsWith('.png')) {
    L.imageOverlay(OVERLAY_URL, BOUNDS, { opacity:0.75, pane:'overlayPane' }).addTo(map);
  }

  // Hotspots (points/centroids)
  function levelToColor(level){
    if (level === "High") return "#e31a1c";
    if (level === "Caution") return "#f59e0b";
    return "#1f78b4";
  }
  // helper: color from percent (0..100)
  function colorFromPercent(p){
    if (p >= 70) return '#ef4444';      // Alert
    if (p >= 40) return '#f59e0b';      // Watch
    return '#22c55e';                   // Healthy/Low
  }
  function pct(x){ return Math.max(0, Math.min(100, Math.round(x*100))); }

  if (HOTSPOTS) {
    fetch(HOTSPOTS, { cache: 'no-store' })
      .then(r => r.json())
      .then(gj => {
        const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));

        const hotspotLayer = L.geoJSON(gj, {
          pointToLayer: (f, latlng) => {
            const riskRaw = f.properties?.risk ?? f.properties?.risk_pct ?? 0;
            const riskPercent = clamp(
              (riskRaw <= 1 ? Math.round(riskRaw * 100) : Math.round(riskRaw)),
              0, 100
            );
            const level   = f.properties?.level || (riskPercent >= 70 ? 'Alert' : (riskPercent >= 40 ? 'Watch' : 'Healthy'));
            const areaHa  = f.properties?.area_ha;
            const reason  = f.properties?.reason || '—';
            const action  = f.properties?.action || '';
            const color   = colorFromPercent(riskPercent);
            const chartB64 = f.properties?.chart_b64;

            // ids
            // ...inside pointToLayer:
            const uidInfo  = 'info_'  + Math.random().toString(36).slice(2, 8);
            const uidChart = 'chart_' + Math.random().toString(36).slice(2, 8);
            const uidBar   = 'bar_'   + Math.random().toString(36).slice(2, 8);
            const uidRiskRow = 'risk_' + Math.random().toString(36).slice(2, 8);
            const uidBtn   = 'btn_'   + Math.random().toString(36).slice(2, 8);

            const html = `
              <div style="min-width:320px;max-width:400px;background:#fff;border-radius:16px;
                          box-shadow:0 10px 30px rgba(2,6,23,.20);padding:18px 20px;
                          font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;color:#0f172a;line-height:1.55">

                <!-- Header -->
                <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
                  <div style="width:14px;height:14px;border-radius:50%;background:${color};
                              box-shadow:0 0 0 2px #fff, 0 0 0 6px ${color}22"></div>
                  <div style="font-weight:800;font-size:15px">Hotspot detected</div>
                </div>

                <!-- Water Risk row (will be hidden in 'why risky' mode) -->
                <div id="${uidRiskRow}" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                  <div style="font-size:14px"><strong>Water Risk</strong></div>
                  <div style="font-size:14px"><strong>${riskPercent}% · ${level}</strong></div>
                </div>

                <!-- Solid color bar (already hidden in 'why risky' mode) -->
                <div id="${uidBar}" style="position:relative;height:12px;border-radius:999px;overflow:hidden;margin-bottom:14px;background:#e5e7eb">
                  <div style="position:absolute;left:0;top:0;bottom:0;width:${riskPercent}%;background:${color};border-radius:999px"></div>
                </div>

                <!-- INFO block -->
                <div id="${uidInfo}">
                  ${areaHa!=null ? `
                  <div style="margin-bottom:12px">
                    <div style="font-size:11px;letter-spacing:.04em;text-transform:uppercase;color:#64748b;font-weight:700">Size</div>
                    <div style="font-size:13px;color:#0f172a;margin-top:2px">${Number(areaHa).toFixed(2)} ha</div>
                  </div>` : ``}

                  <div style="margin-bottom:12px">
                    <div style="font-size:11px;letter-spacing:.04em;text-transform:uppercase;color:#64748b;font-weight:700">Why risky</div>
                    <div style="font-size:13px;color:#0f172a;margin-top:2px">${reason}</div>
                  </div>

                  ${action ? `
                  <div style="margin-bottom:2px">
                    <div style="font-size:11px;letter-spacing:.04em;text-transform:uppercase;color:#64748b;font-weight:700">What you should do</div>
                    <div style="font-size:13px;color:#0f172a;margin-top:2px">${action}</div>
                  </div>` : ``}
                </div>

                <!-- CHART block -->
                ${chartB64 ? `
                <div id="${uidChart}" style="display:none">
                  <div style="font-size:11px;letter-spacing:.04em;text-transform:uppercase;color:#64748b;font-weight:700;margin-bottom:8px">Why risky</div>
                  <img src="data:image/png;base64,${chartB64}" alt="Why risky contributions"
                      style="display:block;width:100%;height:auto;border-radius:8px;image-rendering:-webkit-optimize-contrast" />
                </div>` : ``}

                <!-- Blue pill toggle -->
                ${chartB64 ? `
                <button id="${uidBtn}" aria-pressed="false"
                  onclick="(function(btn){
                    const info  = document.getElementById('${uidInfo}');
                    const chart = document.getElementById('${uidChart}');
                    const bar   = document.getElementById('${uidBar}');
                    const risk  = document.getElementById('${uidRiskRow}');
                    const showingChart = chart.style.display !== 'none';
                    if (showingChart){
                      chart.style.display='none';
                      info.style.display='block';
                      if(bar)  bar.style.display='block';
                      if(risk) risk.style.display='flex';      // ✅ show the 'Water Risk 68% · Caution' line again
                      btn.textContent='Show why risky';
                      btn.setAttribute('aria-pressed','false');
                    } else {
                      info.style.display='none';
                      chart.style.display='block';
                      if(bar)  bar.style.display='none';
                      if(risk) risk.style.display='none';      // ✅ hide the 'Water Risk 68% · Caution' line
                      btn.textContent='Back to info';
                      btn.setAttribute('aria-pressed','true');
                    }
                  })(this)"
                  style="display:block;width:100%;padding:10px 0;border:none;border-radius:999px;
                        background:#3b82f6;color:#fff;font-size:13px;font-weight:700;
                        box-shadow:0 1px 0 rgba(255,255,255,.4) inset, 0 2px 10px rgba(59,130,246,.35);
                        cursor:pointer;margin-top:12px;transition:transform .06s ease, background .2s ease;">
                  Show why risky
                </button>` : ``}
              </div>`;

            const m = L.circleMarker(latlng, {
              radius: 6,
              color: '#0f172a',
              weight: 1,
              fillColor: color,
              fillOpacity: 0.9
            });

            m.bindPopup(html, { maxWidth: 440, className: 'hotspot-popup' });
            return m;
          }
        });

        hotspotLayer.addTo(map);
      })
      .catch(()=>{});
  }

  /* ===== helpers (keep if you already have them) ===== */
  const pill = document.getElementById("hoverpill");
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function pct(x){ return Math.round(clamp01(x)*100); }
  function levelFrom(v){ return v>=0.7 ? "High" : v>=0.4 ? "Caution" : "Low"; }
  function colorFor(v){ return v>=0.7 ? '#e31a1c' : v>=0.4 ? '#f59e0b' : '#2ecc71'; }
  function tipsFor(level){
    if (level==="High")    return "Standing water likely. Drain within 24h; open outlets/pump.";
    if (level==="Caution") return "Watch next 2–3 days. Avoid heavy irrigation; check after rain.";
    return "Normal. Maintain current irrigation schedule.";
  }

  /* ===== LOAD PROBE (robust to u8/u16/f32 + appended mask) =====
    Back-end writes: uint16 [0..1000] + optional uint8 AOI mask appended.
    Meta example:
    { rows, cols, scale:1000, web_bounds:[[S,W],[N,E]], layout:{data_bytes, mask_bytes?} }
    */
  let probeMeta=null, probeArray=null, maskArray=null, dtype=null, canClient=false;
  let EFFECTIVE_BOUNDS = BOUNDS;  // will be replaced by meta.web_bounds if present

  (async function(){
    try{
      if (!PROBE_BIN || !PROBE_META) return;
      // 1) meta
      probeMeta = await fetch(PROBE_META, {cache:'no-store'}).then(r=>r.json());
      // normalize meta keys
      const W = probeMeta.cols ?? probeMeta.width;
      const H = probeMeta.rows ?? probeMeta.height;
      probeMeta.width = Number(W); probeMeta.height = Number(H);
      probeMeta.scale = probeMeta.scale || 1000; // your pipeline scale
      if (Array.isArray(probeMeta.web_bounds)) EFFECTIVE_BOUNDS = probeMeta.web_bounds; // match web grid

      // 2) data
      const buf = await fetch(PROBE_BIN, {cache:'no-store'}).then(r=>r.arrayBuffer());
      const npx = probeMeta.width * probeMeta.height;
      const layout = probeMeta.layout || {};
      const dataBytes = layout.data_bytes ?? (npx*2);         // default u16
      const maskBytes = layout.mask_bytes ?? 0;

      // Expect: [data][mask?]
      if (buf.byteLength < dataBytes) throw new Error("Probe buffer smaller than data_bytes");
      const dataView = buf.slice(0, dataBytes);
      const maskView = (maskBytes>0 && buf.byteLength >= dataBytes+maskBytes) ? buf.slice(dataBytes, dataBytes+maskBytes) : null;

      // Decide dtype by dataBytes/npx
      if (dataBytes === npx)       { probeArray = new Uint8Array(dataView);  dtype='u8'; }
      else if (dataBytes === npx*2){ probeArray = new Uint16Array(dataView); dtype='u16'; }
      else if (dataBytes === npx*4){ probeArray = new Float32Array(dataView);dtype='f32'; }
      else {
        // be tolerant: try u16 if divisible by 2
        probeArray = (dataBytes % 4 === 0) ? new Float32Array(dataView)
                  : (dataBytes % 2 === 0) ? new Uint16Array(dataView)
                  : new Uint8Array(dataView);
        dtype = (probeArray.BYTES_PER_ELEMENT===4) ? 'f32' : (probeArray.BYTES_PER_ELEMENT===2 ? 'u16' : 'u8');
        console.warn("Nonstandard data_bytes; inferred dtype =", dtype);
      }

      if (maskView) {
        maskArray = new Uint8Array(maskView); // 0=outside AOI, 1=inside
        if (maskArray.length !== npx) {
          console.warn("Mask size mismatch (ignoring mask)", maskArray.length, "vs", npx);
          maskArray = null;
        }
      }
      canClient = !!(probeArray && probeMeta.width && probeMeta.height);
      console.log("Probe ready:", {dtype, w:probeMeta.width, h:probeMeta.height, scale:probeMeta.scale, hasMask:!!maskArray});
    }catch(e){
      console.warn("Probe load failed:", e);
      canClient=false;
    }
  })();

  /* ===== SAMPLE A PIXEL FROM PROBE ===== */
  function sampleClient(latlng){
    if (!canClient) return null;
    const [[S,W],[N,E]] = EFFECTIVE_BOUNDS;
    const x = Math.floor(((latlng.lng - W) / (E - W)) * probeMeta.width);
    const y = Math.floor(((N - latlng.lat) / (N - S)) * probeMeta.height);
    if (x<0 || x>=probeMeta.width || y<0 || y>=probeMeta.height) return null;
    const idx = y*probeMeta.width + x;

    // ✅ Respect AOI mask
    if (maskArray && maskArray[idx] === 0) return null;

    let v01;
    if (dtype==='u8')       v01 = probeArray[idx] / 255;
    else if (dtype==='u16') v01 = probeArray[idx] / (probeMeta.scale || 1000);
    else {
      const raw = probeArray[idx];
      const hasMM = Number.isFinite(probeMeta.min) && Number.isFinite(probeMeta.max) && (probeMeta.max>probeMeta.min);
      v01 = hasMM ? (raw - probeMeta.min) / (probeMeta.max - probeMeta.min) : raw;
    }
    if (!Number.isFinite(v01)) return null;
    return { v: clamp01(v01) };
  }

  /* ===== SMOOTH HOVER (rAF + EMA), with server fallback only if probe missing ===== */
  let lastLL=null, emaV=null, raf=0, srvCooldown=false;
  function renderPill(ll){
    const c = sampleClient(ll);

    // if no valid risk value → hide pill immediately
    if (!c){
      pill.style.display = 'none';
      emaV = null;  // reset smoothed value
      return;
    }

    // if inside AOI/raster → update pill
    emaV = (emaV==null) ? c.v : (0.6*emaV + 0.4*c.v);
    const v = clamp01(emaV);
    const p = pct(v), lvl = levelFrom(v), col = colorFor(v);

    const pt = map.latLngToContainerPoint(ll);
    pill.style.display='block';
    pill.style.left=(pt.x+14)+'px';
    pill.style.top=(pt.y+14)+'px';

    pill.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:2px;min-width:180px">
        <div>Waterlogging risk · ${p}% · ${lvl}</div>
        <div style="width:100%;height:6px;background:#e5e7eb;border-radius:999px;overflow:hidden">
          <span style="display:block;height:100%;width:${p}%;background:${col}"></span>
        </div>
      </div>`;
  }
  function loop(){
    raf = requestAnimationFrame(loop);
    if (lastLL) renderPill(lastLL);

    // Only fallback if we never got the client probe at all
    if (!canClient && lastLL && !srvCooldown){
      srvCooldown = true; setTimeout(()=>srvCooldown=false, 200);
      fetch(`/probe/${JOB_ID}?lat=${lastLL.lat}&lon=${lastLL.lng}`)
        .then(r=>r.ok?r.json():null).then(d=>{
          if (d && typeof d.value==='number'){
            const v = clamp01(d.value);
            emaV = (emaV==null) ? v : (0.6*emaV + 0.4*v);
          }
        }).catch(()=>{});
    }
  }
  map.on('mousemove', e=>{ lastLL=e.latlng; if(!raf) loop(); });
  map.on('mouseout', ()=>{ lastLL=null; emaV=null; pill.style.display='none'; cancelAnimationFrame(raf); raf=0; });

  /* ===== CLICK: freeze popup with level-specific tips ===== */
  map.on('click', async (e)=>{
    let v = sampleClient(e.latlng)?.v;
    if (v==null && !canClient){ // only if client probe missing entirely
      try{
        const r = await fetch(`/probe/${JOB_ID}?lat=${e.latlng.lat}&lon=${e.latlng.lng}`);
        const d = await r.json(); if (typeof d?.value==='number') v = clamp01(d.value);
      }catch{}
    }
    if (v==null) return;
    const p=pct(v), lvl=levelFrom(v), col=colorFor(v);
    const html = `
      <div style="min-width:260px">
        <b>Waterlogging risk</b>
        <div style="margin-top:6px;font-size:12px;color:#334155">Value: ${p}% · <b>${lvl}</b></div>
        <div style="width:100%;height:8px;background:#e5e7eb;border-radius:999px;margin-top:6px;overflow:hidden">
          <span style="display:block;height:100%;width:${p}%;background:${col}"></span>
        </div>
        <div style="margin-top:8px;font-size:12px;color:#64748b"><i>Tip:</i> ${tipsFor(lvl)}</div>
      </div>`;
    L.popup({offset:[0,-6]}).setLatLng(e.latlng).setContent(html).openOn(map);
  });
  /* ================= INSIGHTS + SCALE ================= */
  const tableWrap = document.getElementById('insightsTable');
  const title     = document.getElementById('insTitle');
  const moreBtn   = document.getElementById('toggleInsights');
  const techBtn   = document.getElementById('techBtn');
  const mapBtn    = document.getElementById('mapOnlyBtn');
  const exitBtn   = document.getElementById('exitMapOnlyBtn');
  const legendDiv = document.getElementById('legendRows');
  const donutCtr  = document.getElementById('donutCenter');

  let farmerHTML = "", techHTML = "", scaleHTML = "", plotHTML = "";
  let techMode = false, expandedFarmer=false, expandedTech=false;

  function applyRowLimit(t, max){
    if (!t || !t.tBodies[0]) return;
    const rows = Array.from(t.tBodies[0].rows);
    rows.forEach((r,i)=>{ r.style.display = (i < max) ? '' : 'none'; });
  }
  function makeSortableAndSparky(t, isTech){
    if (!t) return;
    const ths = t.querySelectorAll('thead th');
    ths.forEach((th, idx)=>{
      th.classList.add('sortable');
      th.onclick = () => sortByColumn(t, idx, th);
    });
    if (!isTech) return;
    const rows = Array.from(t.tBodies[0]?.rows || []);
    const cols = ths.length;
    const isNumeric = Array(cols).fill(false);
    for (let c=1; c<cols; c++){
      const sample = rows.slice(0, Math.min(12, rows.length))
        .map(r => parseFloat((r.cells[c]?.innerText || '').replace(/[, ]/g,'')));
      const valid = sample.filter(v => Number.isFinite(v)).length;
      isNumeric[c] = valid >= Math.ceil(sample.length*0.6);
    }
    const min = Array(cols).fill(+Infinity), max = Array(cols).fill(-Infinity);
    rows.forEach(r=>{
      for (let c=1; c<cols; c++){
        if (!isNumeric[c]) continue;
        const v = parseFloat((r.cells[c].innerText||'').replace(/[, ]/g,''));
        if (Number.isFinite(v)){ if (v<min[c]) min[c]=v; if (v>max[c]) max[c]=v; }
      }
    });
    rows.forEach(r=>{
      for (let c=1; c<cols; c++){
        if (!isNumeric[c]) continue;
        const cell = r.cells[c];
        const v = parseFloat((cell.innerText||'').replace(/[, ]/g,''));
        let p = 0;
        if (Number.isFinite(v) && max[c] > min[c]) p = (v-min[c])/(max[c]-min[c])*100;
        cell.classList.add('spark');
        cell.style.setProperty('--pct', p.toFixed(2));
      }
    });
  }
  function sortByColumn(table, colIdx, thEl, dir){
    const tbody = table.tBodies[0];
    const rows  = Array.from(tbody.rows);
    const asc = (dir === 'asc') ? true : (dir === 'desc') ? false : !thEl.classList.contains('asc');
    const parseVal = (s)=>{
      const txt = (s||'').trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(txt)) return new Date(txt).getTime();
      const n = parseFloat(txt.replace(/[, ]/g,''));
      return Number.isFinite(n) ? n : txt;
    };
    rows.sort((a,b)=>{
      const A = parseVal(a.cells[colIdx]?.innerText);
      const B = parseVal(b.cells[colIdx]?.innerText);
      if (typeof A === 'number' && typeof B === 'number') return asc ? (A-B) : (B-A);
      return asc ? String(A).localeCompare(String(B)) : String(A).localeCompare(String(B)) * -1;
    });
    table.querySelectorAll('th').forEach(th=>th.classList.remove('asc'));
    if (asc) thEl.classList.add('asc');
    rows.forEach(r=>tbody.appendChild(r));
  }

  function buildDonutMatchBars(){
    const svg  = document.querySelector('.scale-donut');
    const segs = svg ? svg.querySelectorAll('.segments .seg') : null;
    const rows = Array.from(document.querySelectorAll('.legend .legrow'));
    if (!svg || !segs || !rows.length) return;

    // total ha → center chip (value + unit)
    const totalHa = rows.reduce((s, r) => s + (parseFloat(r.dataset.ha) || 0), 0);
    const val = (totalHa || 0);
    const valStr = (val < 10) ? val.toFixed(2) : (val < 100 ? val.toFixed(1) : Math.round(val).toString());
    const center = document.getElementById('donutCenter');
    if (center) center.textContent = valStr;

    segs.forEach((seg, i) => {
      const row = rows[i]; if (!row) return;
      const pct = Math.max(0, Math.min(100, parseFloat(row.dataset.pct)||0));
      const color = row.style.getPropertyValue('--c') || getComputedStyle(row).getPropertyValue('--c') || '#9ca3af';
      seg.setAttribute('stroke', color.trim());
      seg.setAttribute('stroke-dasharray', `${pct} ${100 - pct}`);
      seg.setAttribute('stroke-dashoffset', '0');
    });
  }
  function ensureFarmerColgroup(t) {
    if (!t || t.classList.contains('has-colgroup')) return;
    if (!t.querySelector('colgroup')) {
      const cg = document.createElement('colgroup');
      // Farmer table: Date | Status | Actions
      ['90px','110px','auto'].forEach(w=>{
        const c = document.createElement('col');
        if (w !== 'auto') c.style.width = w;
        cg.appendChild(c);
      });
      t.insertBefore(cg, t.firstChild);
    }
    t.classList.add('has-colgroup');
  }
  function renderTables(){
    const maxF = Number(tableWrap?.dataset?.max ?? 5);
    const maxT = Number(tableWrap?.dataset?.techMax ?? 5);

    if (techMode) {
      title.innerHTML = 'Technical Details <span class="hint" data-tip="Detailed raw indicators from Sentinel-1 (VH/VV, ratios, etc.). Useful for agronomists and advanced users."></span>';
      tableWrap.innerHTML = techHTML || "<div class='empty'>No records.</div>";
      moreBtn.textContent = expandedTech ? 'Show less' : 'Show more';
      techBtn.textContent = 'Exit Technical Details';
      const t = tableWrap.querySelector('table');
      if (t){ t.classList.add('minitable','tech'); makeSortableAndSparky(t, true);
        const dateTH = t.querySelector('thead th:first-child'); if (dateTH) sortByColumn(t, 0, dateTH, 'desc');
        if (!expandedTech) applyRowLimit(t, maxT);
      }
    } else {
      title.innerHTML = 'Per-pass Insights <span class="hint" data-tip="Shows each satellite pass. Farmers can check the date, risk status, and suggested action. Helpful for deciding when to irrigate or drain."></span>';
      tableWrap.innerHTML = farmerHTML || "<div class='empty'>No records.</div>";
      moreBtn.textContent = expandedFarmer ? 'Show less' : 'Show more';
      techBtn.textContent = 'Show Technical Details';

      const t = tableWrap.querySelector('table');
      if (t){
        ensureFarmerColgroup(t);             // sets Date/Value/Risk/Area/Action widths
        t.classList.add('minitable','farmer');
        const dateTH = t.querySelector('thead th:first-child');
        if (dateTH) sortByColumn(t, 0, dateTH, 'desc');
        if (!expandedFarmer) applyRowLimit(t, maxF);
      }
    }
    buildDonutMatchBars();
  }

  function setMapOnly(on){
    document.body.classList.toggle('map-only', !!on);
    const isOn = document.body.classList.contains('map-only');
    mapBtn.textContent  = isOn ? 'Exit Map Only' : 'Map Only';
    exitBtn.style.display = isOn ? '' : 'none';
    setTimeout(()=> map.invalidateSize(true), 200);
  }

  moreBtn.onclick = ()=>{
    if (techMode) expandedTech = !expandedTech;
    else          expandedFarmer = !expandedFarmer;
    renderTables();
  };
  techBtn.onclick = ()=>{ techMode = !techMode; renderTables(); };
  mapBtn.onclick  = ()=> setMapOnly(!document.body.classList.contains('map-only'));
  exitBtn.onclick = ()=> setMapOnly(false);
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') setMapOnly(false); });

  // fetch insights (HTML chunks your view already produces)
  (async function(){
    try{
      const res = await fetch(`/fields/${FIELD_ID}/insights/`, {cache:'no-store'});
      const data = await res.json();
      farmerHTML = data.farmer_table_html || "";
      techHTML   = data.technical_table_html || "";
      scaleHTML  = data.legend_rows_html || "";
      plotHTML   = data.plot_section || "";
      document.getElementById("plotSection").innerHTML = plotHTML;
      document.getElementById("legendRows").innerHTML  = scaleHTML;
      renderTables();
    }catch(err){
      console.error("Insights load failed:", err);
      farmerHTML = ""; techHTML = ""; scaleHTML = ""; plotHTML = "";
      renderTables();
    }
  })();
</script>
{% endblock %}

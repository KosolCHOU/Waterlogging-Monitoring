<!-- templates/dashboard.html -->
{% extends "base.html" %}
{% block title %}Dashboard – CropXcel{% endblock %}
{% block head %}
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <style>
    body{margin:0;font-family:system-ui,Arial,sans-serif;display:flex;height:100vh}
    #map{flex:1}
    #side{width:420px;overflow-y:auto;border-left:1px solid #e5e7eb;background:#fff;padding:16px}
    h3{margin:12px 0 6px;font-size:15px;color:#0f172a}
    .panel{margin-bottom:18px;padding:12px;border-radius:10px;box-shadow:0 1px 3px rgba(0,0,0,.1)}
    .water-advice{background:#fef9c3;border-left:5px solid #f59e0b;padding:12px;border-radius:8px}
  </style>
{% endblock %}

{% block content %}
  <div id="map"></div>
<div id="plot-section"></div>

<div class="insights">
  <div class="panel">
    <h3>Farmer View</h3>
    <div id="farmer-table"></div>
  </div>

  <div class="panel">
    <h3>Technical View</h3>
    <div id="technical-table"></div>
  </div>

  <div class="panel">
    <h3>Analysis Scale</h3>
    <div class="legend">
      <div id="legend-rows"></div>
      <div class="total">Total: <span id="total-badge">—</span></div>
    </div>
  </div>
</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const JOB_ID = {{ job_id|safe }};
    const BOUNDS = {{ bounds|safe }};
    const TILE_URL = "";  // force PNG route
    const OVERLAY_URL = "{{ overlay_png|default:'' }}";
    const HOTSPOTS = "{{ hotspots_url|default:'' }}";
    const map = L.map('map');
    L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      { attribution: 'Tiles © Esri' }
    ).addTo(map);
    map.fitBounds(BOUNDS);

    // Put overlays on their own pane so they sit above base tiles.
    map.createPane('overlayPane');
    map.getPane('overlayPane').style.zIndex = 450;

    let overlay = null;
    if (OVERLAY_URL && OVERLAY_URL.endsWith('.png')) {
      overlay = L.imageOverlay(OVERLAY_URL, BOUNDS, { opacity: 0.75, pane: 'overlayPane' }).addTo(map);
    }

    // ---- Hotspots ----
    function levelToColor(level){
      if (level === "High") return "#e31a1c";
      if (level === "Caution") return "#f59e0b";
      return "#1f78b4";
    }
    function pct(x){ return Math.max(0, Math.min(100, Math.round(x*100))); }

    if (HOTSPOTS) {
      fetch(HOTSPOTS, { cache: 'no-store' })
        .then(r => r.json())
        .then(gj => {
          L.geoJSON(gj, {
            pointToLayer: function(f, latlng){
              // Use risk (0..1) if present; else compute from risk_pct
              const hasRisk = typeof f.properties?.risk === "number" && isFinite(f.properties.risk);
              const rpct = Number(f.properties?.risk_pct);
              const risk = hasRisk ? Number(f.properties.risk)
                                  : (isFinite(rpct) ? Math.max(0, Math.min(100, rpct)) / 100 : 0);

              const level = f.properties?.level || (risk>=0.7 ? "High" : risk>=0.4 ? "Caution" : "Low");
              const color = levelToColor(level);

              const m = L.circleMarker(latlng, {
                radius: 6, color: "#111", weight: 1, opacity: 0.9,
                fillColor: color, fillOpacity: 0.9
              });

              m.bindTooltip(`Risk: ${pct(risk)}% · ${level}`, {direction:"top", offset:[0,-6]});

              const reason = f.properties?.reason || "Potential waterlogging area";
              const action = f.properties?.action || "";
              const chart  = f.properties?.chart_b64 ? `<img src="data:image/png;base64,${f.properties.chart_b64}" style="width:100%;border-radius:8px;margin-top:8px">` : "";

              const html = `
                <div style="min-width:240px">
                  <div style="display:flex;align-items:center;gap:8px">
                    <div style="width:10px;height:10px;border-radius:50%;background:${color}"></div>
                    <b>Hotspot</b>
                  </div>
                  <div class="riskbar" style="margin-top:6px">
                    <span class="${level==='High'?'risk-high':level==='Caution'?'risk-caution':'risk-low'}" style="width:${pct(risk)}%"></span>
                  </div>
                  <div style="margin-top:8px;font-size:12px;color:#334155">
                    <div><b>Risk:</b> ${pct(risk)}% · ${level}</div>
                    ${f.properties?.area_ha ? `<div><b>Area:</b> ${Number(f.properties.area_ha).toFixed(4)} ha</div>` : ``}
                    <div><b>Reason:</b> ${reason}</div>
                    ${action ? `<div style="margin-top:4px"><b>Action:</b> ${action}</div>` : ``}
                  </div>
                  ${chart}
                </div>`;
              m.bindPopup(html);
              return m;
            }
          }).addTo(map);
        })
        .catch(_ => {});
    }

    // ---- Hover probe (server-assisted; falls back silently) ----
    const pill = document.getElementById("hoverpill");
    let probeTimer = null;
    function showPill(text){ pill.style.display='block'; pill.textContent = text; }
    function hidePill(){ pill.style.display='none'; }

    map.on("mousemove", (e) => {
      // throttle
      if (probeTimer) return;
      probeTimer = setTimeout(() => { probeTimer = null; }, 180);

      const { lat, lng } = e.latlng;
      fetch(`/probe/${JOB_ID}?lat=${lat}&lon=${lng}`)
        .then(r => r.ok ? r.json() : Promise.reject())
        .then(d => {
          if (d && typeof d.value === "number") {
            const p = Math.round(d.value * 100);
            const lvl = d.level || (d.value>=0.7 ? "High" : d.value>=0.4 ? "Caution" : "Low");
            showPill(`risk: ${p}% · ${lvl}`);
          } else {
            hidePill();
          }
        })
        .catch(_ => hidePill());
    });

    const PROBE_BIN  = "{{ probe_bin|default:'' }}";
    const PROBE_META = "{{ probe_meta|default:'' }}";

    let probe = null;  // { rows, cols, south, west, north, east, data: Uint16Array, mask: Uint8Array|null, scale }
    let tip = null, raf = null, lastIdx = -2;

    async function loadProbe() {
      if (!PROBE_META || !PROBE_BIN) return;
      const meta = await fetch(PROBE_META, {cache:'no-store'}).then(r=>r.json());
      const resp = await fetch(PROBE_BIN, {cache:'no-store'});
      const buf = await resp.arrayBuffer();

      const rows = meta.rows, cols = meta.cols;
      const [[south, west],[north, east]] = meta.web_bounds;  // web grid bounds (EPSG:4326)
      const scale = meta.scale || 1000;

      const dataBytes = meta.layout?.data_bytes ?? (rows*cols*2);
      const data = new Uint16Array(buf.slice(0, dataBytes));
      let mask = null;
      if (meta.has_mask) {
        mask = new Uint8Array(buf.slice(dataBytes, dataBytes + rows*cols));
      }
      probe = {rows, cols, south, west, north, east, scale, data, mask};
    }

    function gridIndex(lat, lng) {
      if (!probe) return -1;
      const {rows, cols, south, west, north, east} = probe;
      if (lat < south || lat > north || lng < west || lng > east) return -1;
      const r = Math.floor((north - lat) / (north - south) * rows);
      const c = Math.floor((lng  - west)  / (east - west)  * cols);
      if (r < 0 || r >= rows || c < 0 || c >= cols) return -1;
      return r*cols + c;
    }

    function mean3x3(idx, rows, cols, data, scale, mask){
      const r0 = Math.floor(idx / cols), c0 = idx % cols;
      let s = 0, n = 0;
      for(let dr=-1; dr<=1; dr++){
        for(let dc=-1; dc<=1; dc++){
          const r = r0 + dr, c = c0 + dc;
          if (r<0 || r>=rows || c<0 || c>=cols) continue;
          const k = r*cols + c;
          if (mask && mask[k] === 0) continue;
          s += data[k]; n++;
        }
      }
      return n ? (s/n)/scale : (data[idx]/scale);
    }

    map.whenReady(async () => {
      await loadProbe();
      tip = L.tooltip({permanent:false, direction:'top', opacity:0.96, offset:[0,-10]});

      map.on('mousemove', (e) => {
        if (!probe) return;
        if (raf) return;
        raf = requestAnimationFrame(() => {
          raf = null;
          const k = gridIndex(e.latlng.lat, e.latlng.lng);
          if (k < 0 || (probe.mask && probe.mask[k] === 0)) {
            if (map.hasLayer(tip)) map.removeLayer(tip);
            lastIdx = -2; return;
          }
          if (k === lastIdx) { tip.setLatLng(e.latlng); if(!map.hasLayer(tip)) tip.addTo(map); return; }
          lastIdx = k;
          // const v = probe.data[k] / probe.scale;
          // const pct = (v*100).toFixed(1);

          const v = mean3x3(k, probe.rows, probe.cols, probe.data, probe.scale, probe.mask);
          const pct = (v*100).toFixed(1);

          // level + color (same thresholds used for hotspots)
          const level = v >= 0.7 ? "High" : (v >= 0.4 ? "Caution" : "Low");
          const color = level === "High" ? "#e31a1c" : (level === "Caution" ? "#f59e0b" : "#1f78b4");

          tip.setLatLng(e.latlng).setContent(
            `<div style="font:13px/1.35 system-ui;min-width:230px">
              <div style="display:flex;align-items:center;gap:8px;font-weight:700;margin-bottom:2px">
                <span style="width:10px;height:10px;border-radius:50%;background:${color};display:inline-block"></span>
                Waterlogging risk · <span style="font-weight:600">${level}</span>
              </div>
              <div style="font-size:12px;color:#0f172a">
                Value: <b>${pct}%</b> <span style="opacity:.6">(${v.toFixed(3)})</span>
              </div>
            </div>`
          ).addTo(map);
        });
      });
      map.on('mouseout', () => { if (map.hasLayer(tip)) map.removeLayer(tip); lastIdx = -2; });
    });
  (async function() {
    const fieldId = {{ field.id }};   // ensure 'field' is in template context
    const url = `/fields/${fieldId}/insights/`;

    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();

      // inject
      document.getElementById("plot-section").innerHTML   = data.plot_section || "";
      document.getElementById("farmer-table").innerHTML   = data.farmer_table_html || "";
      document.getElementById("technical-table").innerHTML= data.technical_table_html || "";
      document.getElementById("legend-rows").innerHTML    = data.legend_rows_html || "";
      document.getElementById("total-badge").textContent  = data.total_badge || "—";
    } catch (err) {
      console.error("Insights load failed:", err);
      document.getElementById("farmer-table").innerHTML = "<div class='empty'>No records.</div>";
    }
  })();
  </script>
{% endblock %}
